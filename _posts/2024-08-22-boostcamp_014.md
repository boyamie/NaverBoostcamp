---
title: "Boostcamp AI Tech (Day 014)"
date: 2024-08-22
layout: post
tags: [Naver Boostcamp, daily report]
---

# 1. 실습
Seaborn은 Python의 데이터 시각화 라이브러리로, 다양한 유형의 차트를 쉽게 생성할 수 있도록 도와줍니다. 여기서는 정형 데이터를 활용하여 Seaborn을 사용해 Categorical, Distribution, Relational, Regression, Matrix를 다룹니다.

### 1. Categorical (범주형 데이터)

범주형 데이터를 시각화하는 데 자주 사용되는 차트는 막대그래프와 박스플롯입니다.

```python
import seaborn as sns
import matplotlib.pyplot as plt

# 예제 데이터셋
tips = sns.load_dataset("tips")

# Categorical: 막대그래프
sns.catplot(x="day", y="total_bill", kind="bar", data=tips)
plt.title("Total Bill by Day")
plt.show()

# Categorical: 박스플롯
sns.catplot(x="day", y="total_bill", kind="box", data=tips)
plt.title("Total Bill Distribution by Day")
plt.show()
```

### 2. Distribution (분포)

데이터의 분포를 이해하기 위해 히스토그램과 커널 밀도 추정(KDE)을 사용합니다.

```python
# Distribution: 히스토그램
sns.histplot(tips['total_bill'], kde=False)
plt.title("Histogram of Total Bill")
plt.show()

# Distribution: KDE 플롯
sns.kdeplot(tips['total_bill'], shade=True)
plt.title("KDE Plot of Total Bill")
plt.show()
```

### 3. Relational (관계형 데이터)

두 변수 간의 관계를 시각화하기 위해 산점도와 선형 회귀선을 그릴 수 있습니다.

```python
# Relational: 산점도
sns.scatterplot(x="total_bill", y="tip", data=tips)
plt.title("Scatter Plot of Total Bill vs Tip")
plt.show()

# Relational: 선형 회귀선 추가
sns.lmplot(x="total_bill", y="tip", data=tips)
plt.title("Linear Regression of Total Bill vs Tip")
plt.show()
```

### 4. Regression (회귀)

회귀 분석은 두 변수 간의 선형 관계를 시각화하고 분석하는 데 사용됩니다.

```python
# Regression: 선형 회귀선
sns.lmplot(x="total_bill", y="tip", data=tips, order=1)
plt.title("Linear Regression of Total Bill vs Tip (Order 1)")
plt.show()

# Regression: 다항 회귀선 (2차)
sns.lmplot(x="total_bill", y="tip", data=tips, order=2)
plt.title("Polynomial Regression of Total Bill vs Tip (Order 2)")
plt.show()
```

### 5. Matrix (행렬)

데이터 간의 상관관계를 보여주는 히트맵은 행렬 데이터의 시각화에 유용합니다.

```python
# Matrix: 상관관계 히트맵
corr = tips.corr()
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.title("Correlation Matrix of Tips Dataset")
plt.show()
```
Seaborn에서 제공하는 Figure-Level API는 전체적인 시각화 구성을 보다 쉽게 관리할 수 있도록 도와줍니다. 이 API는 단일 플롯보다는 복합적인 여러 플롯을 한 번에 그리기 위한 것입니다. `jointplot`, `pairplot`, `FacetGrid`를 사용하여 다양한 시각화를 생성하는 방법을 다룹니다.

### 1. `jointplot`
`jointplot`은 두 변수 간의 관계를 시각화하며, 산점도와 함께 각 변수의 분포를 동시에 보여줍니다.

```python
import seaborn as sns
import matplotlib.pyplot as plt

# 예제 데이터셋
tips = sns.load_dataset("tips")

# jointplot: 산점도 + 히스토그램
sns.jointplot(x="total_bill", y="tip", data=tips, kind="scatter")
plt.suptitle("Joint Plot of Total Bill vs Tip", y=1.02)
plt.show()

# jointplot: 회귀선 + KDE
sns.jointplot(x="total_bill", y="tip", data=tips, kind="reg")
plt.suptitle("Joint Plot with Regression Line", y=1.02)
plt.show()
```

### 2. `pairplot`
`pairplot`은 데이터셋의 각 변수 쌍에 대한 산점도와 히스토그램을 자동으로 생성하여, 변수들 간의 관계를 전체적으로 이해할 수 있도록 도와줍니다.

```python
# pairplot: 모든 변수 간의 관계 시각화
sns.pairplot(tips)
plt.suptitle("Pair Plot of Tips Dataset", y=1.02)
plt.show()

# pairplot: 특정 변수에 따라 색상을 다르게 표시
sns.pairplot(tips, hue="smoker")
plt.suptitle("Pair Plot by Smoker Status", y=1.02)
plt.show()
```

### 3. `FacetGrid`
`FacetGrid`는 데이터를 서브셋으로 나누어 여러 개의 플롯을 배열하는 데 사용됩니다. 이를 통해 조건에 따라 데이터의 분포와 관계를 비교할 수 있습니다.

```python
# FacetGrid: 여러 서브플롯 생성
g = sns.FacetGrid(tips, col="time", row="smoker")
g.map(sns.scatterplot, "total_bill", "tip")
g.add_legend()
plt.suptitle("FacetGrid of Total Bill vs Tip by Time and Smoker Status", y=1.02)
plt.show()

# FacetGrid: 히스토그램을 사용한 서브플롯
g = sns.FacetGrid(tips, col="sex", row="day", margin_titles=True)
g.map(sns.histplot, "total_bill")
g.add_legend()
plt.suptitle("FacetGrid of Total Bill by Sex and Day", y=1.02)
plt.show()
```

차원 축소는 고차원 데이터를 저차원으로 변환하여 중요한 패턴이나 구조를 시각화하고 분석하는 데 유용합니다. 각 기법의 결과물을 비교하여 장단점을 공부했습니다.

### 1. 데이터 준비 및 라이브러리 임포트

```python
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap.umap_ as UMAP
from sklearn.datasets import load_iris
import pandas as pd

# 데이터셋 로드 (Iris 데이터셋 사용)
iris = load_iris()
data = iris.data
target = iris.target
target_names = iris.target_names

# 데이터프레임으로 변환
df = pd.DataFrame(data, columns=iris.feature_names)
df['target'] = target
df['target_name'] = [target_names[i] for i in target]
```

### 2. PCA (Principal Component Analysis)

PCA는 데이터의 분산을 최대한 보존하면서 저차원으로 변환하는 선형 차원 축소 기법입니다.

```python
# PCA를 통해 2차원으로 축소
pca = PCA(n_components=2)
pca_result = pca.fit_transform(data)

# 시각화
df['PCA1'] = pca_result[:, 0]
df['PCA2'] = pca_result[:, 1]

plt.figure(figsize=(8, 6))
sns.scatterplot(x='PCA1', y='PCA2', hue='target_name', data=df, palette='viridis')
plt.title("PCA of Iris Dataset")
plt.show()
```

### 3. t-SNE (t-Distributed Stochastic Neighbor Embedding)

t-SNE는 고차원 데이터를 저차원으로 변환할 때 데이터의 국소적인 구조를 잘 보존하는 비선형 기법입니다.

```python
# t-SNE를 통해 2차원으로 축소
tsne = TSNE(n_components=2, random_state=42)
tsne_result = tsne.fit_transform(data)

# 시각화
df['tSNE1'] = tsne_result[:, 0]
df['tSNE2'] = tsne_result[:, 1]

plt.figure(figsize=(8, 6))
sns.scatterplot(x='tSNE1', y='tSNE2', hue='target_name', data=df, palette='viridis')
plt.title("t-SNE of Iris Dataset")
plt.show()
```

### 4. UMAP (Uniform Manifold Approximation and Projection)

UMAP은 데이터의 글로벌 구조와 로컬 구조를 모두 잘 보존하는 비선형 차원 축소 기법입니다.

```python
# UMAP을 통해 2차원으로 축소
umap = UMAP(n_components=2, random_state=42)
umap_result = umap.fit_transform(data)

# 시각화
df['UMAP1'] = umap_result[:, 0]
df['UMAP2'] = umap_result[:, 1]

plt.figure(figsize=(8, 6))
sns.scatterplot(x='UMAP1', y='UMAP2', hue='target_name', data=df, palette='viridis')
plt.title("UMAP of Iris Dataset")
plt.show()
```

### 5. 결과물 비교 및 장단점 논의

- **PCA**: 
  - **장점**: 매우 빠르고, 변환 후 결과가 직관적이며 해석하기 쉽습니다.
  - **단점**: 데이터의 선형적 구조만을 보존하기 때문에, 비선형적 관계를 잘 반영하지 못합니다.

- **t-SNE**: 
  - **장점**: 데이터의 국소적 구조를 잘 보존하여 복잡한 데이터의 패턴을 효과적으로 시각화할 수 있습니다.
  - **단점**: 비교적 느리고, 다른 하이퍼파라미터에 매우 민감하여 재현성이 떨어질 수 있습니다.

- **UMAP**: 
  - **장점**: 데이터의 글로벌 구조와 로컬 구조를 모두 잘 보존하며, 속도도 빠릅니다. t-SNE보다 재현성이 좋고, 대규모 데이터셋에 적합합니다.
  - **단점**: 하이퍼파라미터 설정에 따라 결과가 달라질 수 있으며, 직관적인 해석이 어려울 수 있습니다.

각 기법을 선택할 때는 데이터의 특성과 목적에 따라 적절한 방법을 선택하는 것이 중요합니다.
